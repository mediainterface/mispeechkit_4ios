#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.6.1 (swiftlang-5.6.0.323.66 clang-1316.0.20.12)
#ifndef MISPEECHKIT_SWIFT_H
#define MISPEECHKIT_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="miSpeechKit",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class NSString;

/// An Object which is used to specify configuration  used for the recognition session.
SWIFT_CLASS("_TtC11miSpeechKit18ApplicationContext")
@interface ApplicationContext : NSObject
/// The SpeaKING system which will be used for the recognition session.
/// If there only is one system this can be left nil.
@property (nonatomic, copy) NSString * _Nullable system;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// An object which will be used to authenticate against the web API.
SWIFT_CLASS("_TtC11miSpeechKit21AuthenticationContext")
@interface AuthenticationContext : NSObject
/// The System to connect with.
/// If there is only one system, this can be nil.
@property (nonatomic, copy) NSString * _Nullable system;
/// The User that is used for the connection.
@property (nonatomic, copy) NSString * _Nullable user;
/// The password of the specified user.
@property (nonatomic, copy) NSString * _Nullable password;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSUUID;
enum SessionState : NSInteger;
@class RecognitionContext;
@class Word;

/// The protocol for the RecognitionCore-Class
SWIFT_PROTOCOL("_TtP11miSpeechKit12IRecognition_")
@protocol IRecognition
/// Describes the current session. If this Id is nil there is no session initialized.
@property (nonatomic, readonly, copy) NSUUID * _Nullable id;
/// Discribes the current state of the recognition session.
@property (nonatomic, readonly) enum SessionState state;
/// Create a new recognition session and reserve a free recognition unit on server.
/// The session is defined between server and this client. The session identifier, that represent the session, is used for each method call internal. Do not change or use this property.
/// If the call is finished the result is notify by callback.
/// The call can only done if no session is started yet.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.initialize(RecognitionContext(user: "Diktierer")) { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param context Defines the user, vocabulary etc. for the newly created session.
///
/// \param completion The method that is called after the session is created or an error occured.
///
- (void)initialize:(RecognitionContext * _Nonnull)context completion:(void (^ _Nonnull)(BOOL))completion;
/// Temporarly add a new word to the vocabulary, which will be removed when the session is closed.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.addWord("Patientenname") { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param word The word as a String, which will be added to the vocabulary
///
/// \param completion The method that is called after the word is added or an error occured.
///
- (void)addWord:(NSString * _Nonnull)word completion:(void (^ _Nonnull)(BOOL))completion;
/// Temporarly add multiple new word to the vocabulary, which will be removed when the session is closed.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.addWords(["Patientenname"]) { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param words A list of words as Strings, which will be added to the vocabulary
///
/// \param completion The method that is called after the words are added or an error occured.
///
- (void)addWords:(NSArray<NSString *> * _Nonnull)words completion:(void (^ _Nonnull)(BOOL))completion;
/// Temporarly add a new word, where the writing differes from the word itself,  to the vocabulary, which will be removed when the session is closed.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.addWordWithDifferentWriting(Word(word: "Patientenname", writingAs: "Patientname")) { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param word The word as an object with a different writing , which will be added to the vocabulary
///
/// \param completion The method that is called after the word is added or an error occured.
///
- (void)addWordWithDifferentWriting:(Word * _Nonnull)word completion:(void (^ _Nonnull)(BOOL))completion;
/// Temporarly add a list of new words, where the writing differes from the word itself,  to the vocabulary, which will be removed when the session is closed.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.addWordsWithDifferentWriting([Word(word: "Patientenname", writingAs: "Patientname")]) { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param words A list of  words as  objects with a different writing , which will be added to the vocabulary
///
/// \param completion The method that is called after the word is added or an error occured.
///
- (void)addWordsWithDifferentWriting:(NSArray<Word *> * _Nonnull)words completion:(void (^ _Nonnull)(BOOL))completion;
/// Start the recognition engine at server and the audio engine. All recorded audio where transfered.
/// Set the text context to help the recognition engine. If line start or dictation start, set the previous context to nil.
/// In case of a connection loss, there will be attempts to reconnect to the server for 10 seconds, afterwards the recording will be stopped and the buffered audio will be dropped.
/// If the reconnect succeded the buffered audio will be transfered ofer to the recognition server and the recoding will continue seamelessly.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.start(previousText: "", followingText: "") { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param previousText The text that is recognized befor the new data should insert.
///
/// \param followingText The text that is after the new text is insert. 
///
/// \param completion The method is called if the recognition engine and the audio engine are started successful or an error occured.
///
- (void)startWithPreviousText:(NSString * _Nonnull)previousText followingText:(NSString * _Nonnull)followingText completion:(void (^ _Nonnull)(BOOL))completion;
/// Stop the recognition at server and force to send the recognized data to client.
/// Stop the audio engine.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.stop { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param completion The method is called if the recognition and and audio engine are stopped successfully of an error occured.
///
- (void)stopWithCompletion:(void (^ _Nonnull)(BOOL))completion;
/// Submitting text to the smart learning web service to train the used vocabulary permanently.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.submitText("Dies ist ein Beispieltext") { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param text The text to submit to smart learning
///
/// \param completion The method that is called when the text is submitted or an error ocurred.
///
- (void)submitText:(NSString * _Nonnull)text completion:(void (^ _Nonnull)(BOOL))completion;
/// Close the current recognition session and release all resources at server.
/// Call this method every time if the recognition session is initialized. If no session is started, nothing happens.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.cleanup { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param completion The method that is called when the cleanup is finished or an error occured.
///
- (void)cleanupWithCompletion:(void (^ _Nonnull)(BOOL))completion;
/// Release all resources at clientside
/// Call this method every time if the recognition session is initialized. If no session is started, nothing happens.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.dispose { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param completion The method that is called when the cleanup is finished or an error occured.
///
- (void)disposeWithCompletion:(void (^ _Nonnull)(BOOL))completion;
@end


/// The Protocol for all delegate methodes needed for the IRecognition-Object
SWIFT_PROTOCOL("_TtP11miSpeechKit20IRecognitionDelegate_")
@protocol IRecognitionDelegate
@optional
/// Is called if the session state is changed.
/// \param state The current session state.
///
- (void)onStateChangedWithState:(enum SessionState)state;
/// Is called if an error occured.
/// \param error The error that is occured.
///
- (void)onErrorWithError:(NSString * _Nonnull)error;
/// Is called if the recognition received result.
/// \param result The recognition result as plain text.
///
- (void)onResultWithResult:(NSString * _Nonnull)result;
/// Is called if a preview result is received.
/// \param previewResult A string with the preview result.
///
- (void)onPreviewResultWithPreviewResult:(NSString * _Nonnull)previewResult;
/// Is called when the voice level changed while recording
/// \param level The current voice level
///
- (void)onVoiceLevelChangedWithLevel:(float)level;
@end


/// An Object which describes an Error in the   SpeaKING context.
SWIFT_CLASS("_TtC11miSpeechKit7MIError")
@interface MIError : NSObject
/// The session id, if the error occured on the server side, describes the session from which the error comes from.
@property (nonatomic, readonly, copy) NSUUID * _Nullable sessionId;
/// The error code of the occured error.
@property (nonatomic, readonly) NSInteger errorCode;
/// A message which describes the error further.
@property (nonatomic, readonly, copy) NSString * _Nonnull errorMessage;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// An object that is used to initialize the recognition session with a specific configuration.
SWIFT_CLASS("_TtC11miSpeechKit18RecognitionContext")
@interface RecognitionContext : NSObject
/// Describes the user who is currently using speech recognition.
@property (nonatomic, copy) NSString * _Nonnull user;
/// Describtes the vocabulary which should be used for the recognition.
/// Can be nil if there only is one vocabulary for the specified user.
@property (nonatomic, copy) NSString * _Nullable vocabulary;
/// Decides whether a speech recognition preview should be delivered or not.
@property (nonatomic) BOOL previewResults;
/// Decides wheather to use the debug mode while using the speech recognition or not.
@property (nonatomic) BOOL debug;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The Core Object to use speech recognition with the SDK.
SWIFT_CLASS("_TtC11miSpeechKit15RecognitionCore")
@interface RecognitionCore : NSObject <IRecognition>
/// The current Session Id.
/// If this Id is nil there is no session initialized.
@property (nonatomic, readonly, copy) NSUUID * _Nullable id;
/// The current session state
/// Discribes the current state of the recognition session.
@property (nonatomic, readonly) enum SessionState state;
/// Create a new recognition session and reserve a free recognition unit on server.
/// The session is defined between server and this client. The session identifier, that represent the session, is used for each method call internal. Do not change or use this property.
/// If the call is finished the result is notify by callback.
/// The call can only done if no session is started yet.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.initialize(RecognitionContext(user: "Diktierer")) { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param context Defines the user, vocabulary etc. for the newly created session.
///
/// \param completion The method that is called after the session is created or an error occured.
///
- (void)initialize:(RecognitionContext * _Nonnull)context completion:(void (^ _Nonnull)(BOOL))completion;
/// Temporarly add a new word to the vocabulary, which will be removed when the session is closed.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.addWord("Patientenname") { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param word The word as a String, which will be added to the vocabulary
///
/// \param completion The method that is called after the word is added or an error occured.
///
- (void)addWord:(NSString * _Nonnull)word completion:(void (^ _Nonnull)(BOOL))completion;
/// Temporarly add multiple new word to the vocabulary, which will be removed when the session is closed.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.addWords(["Patientenname"]) { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param words A list of words as Strings, which will be added to the vocabulary
///
/// \param completion The method that is called after the words are added or an error occured.
///
- (void)addWords:(NSArray<NSString *> * _Nonnull)words completion:(void (^ _Nonnull)(BOOL))completion;
/// Temporarly add a new word, where the writing differes from the word itself,  to the vocabulary, which will be removed when the session is closed.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.addWordWithDifferentWriting(Word(word: "Patientenname", writingAs: "Patientname")) { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param word The word as an object with a different writing , which will be added to the vocabulary
///
/// \param completion The method that is called after the word is added or an error occured.
///
- (void)addWordWithDifferentWriting:(Word * _Nonnull)word completion:(void (^ _Nonnull)(BOOL))completion;
/// Temporarly add a list of new words, where the writing differes from the word itself,  to the vocabulary, which will be removed when the session is closed.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.addWordsWithDifferentWriting([Word(word: "Patientenname", writingAs: "Patientname")]) { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param words A list of  words as  objects with a different writing , which will be added to the vocabulary
///
/// \param completion The method that is called after the word is added or an error occured.
///
- (void)addWordsWithDifferentWriting:(NSArray<Word *> * _Nonnull)words completion:(void (^ _Nonnull)(BOOL))completion;
/// Start the recognition engine at server and the audio engine. All recorded audio where transfered.
/// Set the text context to help the recognition engine. If line start or dictation start, set the previous context to nil.
/// In case of a connection loss, there will be attempts to reconnect to the server for 10 seconds, afterwards the recording will be stopped and the buffered audio will be dropped.
/// If the reconnect succeded the buffered audio will be transfered ofer to the recognition server and the recoding will continue seamelessly.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.start(previousText: "", followingText: "") { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param previousText The text that is recognized befor the new data should insert.
///
/// \param followingText The text that is after the new text is insert. 
///
/// \param completion The method is called if the recognition engine and the audio engine are started successful or an error occured.
///
- (void)startWithPreviousText:(NSString * _Nonnull)previousText followingText:(NSString * _Nonnull)followingText completion:(void (^ _Nonnull)(BOOL))completion;
/// Stop the recognition at server and force to send the recognized data to client.
/// Stop the audio engine.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.stop { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param completion The method is called if the recognition and and audio engine are stopped successfully of an error occured.
///
- (void)stopWithCompletion:(void (^ _Nonnull)(BOOL))completion;
/// Submitting text to the smart learning web service to train the used vocabulary permanently.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.submitText("Dies ist ein Beispieltext") { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param text The text to submit to smart learning
///
/// \param completion The method that is called when the text is submitted or an error ocurred.
///
- (void)submitText:(NSString * _Nonnull)text completion:(void (^ _Nonnull)(BOOL))completion;
/// Close the current recognition session and release all resources at server.
/// Call this method every time if the recognition session is initialized. If no session is started, nothing happens.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.cleanup { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param completion The method that is called when the cleanup is finished or an error occured.
///
- (void)cleanupWithCompletion:(void (^ _Nonnull)(BOOL))completion;
/// Release all resources at clientside
/// Call this method every time if the recognition session is initialized. If no session is started, nothing happens.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.dispose { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param completion The method that is called when the cleanup is finished or an error occured.
///
- (void)disposeWithCompletion:(void (^ _Nonnull)(BOOL))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// The session state represent a recognition session. This values are set at recognition server.
typedef SWIFT_ENUM(NSInteger, SessionState, open) {
/// The session state is unknown or no session is started at the moment.
  SessionStateUnknown = 0,
/// The session  is created but the server is not ready to start the recognition.
  SessionStateCreated = 1,
/// The session will be ready soon. The Recording can be started and will be recognized as soon as the session is ready.
  SessionStateLoading = 2,
/// Started session is ready for  recognition.
  SessionStateReady = 3,
/// The session is updating the vocabulary and the new one will be available soon.
  SessionStateUpdating = 4,
/// The recognition is in process and the server waits for the audio data.
  SessionStateInProcess = 5,
/// The recognition is unloading. The Recording should be finished and the session is near to be closed.
  SessionStateUnloading = 6,
/// The session is suspended after no audio data where transfered a while. The session is restarted if new audio data where available but it can take a while.
  SessionStateSuspended = 7,
/// The session is stopped and all resources are released at the server. The session can not recreated to continue recognition.
/// Create a new session if recognition should continue.
  SessionStateClosed = 8,
/// An error occuered during session creation. The session is closed and the error state is set. See callback method for more information.
  SessionStateError = 9,
};


/// This class is used to generate and configure a recognition and to pre select an available recognition server.
/// <h1>Usage</h1>
/// \code
///
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) {
///     recognition, error
///     // TODO: Your Code here
/// }
///
///
/// \endcode
SWIFT_CLASS("_TtC11miSpeechKit8SpeaKING")
@interface SpeaKING : NSObject
/// Initialized a configured instance of
/// <h1>Usage</h1>
/// \code
///
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) {
///      recognition, error
///      // TODO: Your Code here
/// }
///
///
/// \endcode\param server The url of the speaking server instance
///
/// \param context The authentication connext for the SpeaKING Server
///
/// \param delegate The delegate to receive updates about the ongoing process of recognition.
///
/// \param completion The completion handle will be triggered, when the recognition api instance is ready for usage.
///
+ (void)getRecognition:(NSString * _Nullable)server context:(AuthenticationContext * _Nullable)context delegate:(id <IRecognitionDelegate> _Nonnull)delegate completion:(void (^ _Nonnull)(id <IRecognition> _Nullable, MIError * _Nullable))completion;
/// Authenticate the given user agaist the coresponding speaking server.
/// #Usage
/// \code
/// SpeaKING.login("http://speaking-server") { error in
///      // TODO: Your code here
/// }
///
///
/// \endcode<ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     server: The url of the speaking server instance
///   </li>
///   <li>
///     context: The authentication context for the speaking instance
///   </li>
///   <li>
///     completion: The complition handle will be triggered when the authentication process is finished.
///   </li>
/// </ul>
+ (void)login:(NSString * _Nullable)server context:(AuthenticationContext * _Nullable)context completion:(void (^ _Nonnull)(MIError * _Nullable))completion;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



/// An Object that specifies a word to add temporarely to a vocabulary
SWIFT_CLASS("_TtC11miSpeechKit4Word")
@interface Word : NSObject
/// The specific word described as a string.
@property (nonatomic, readonly, copy) NSString * _Nonnull word;
/// Defines an alternative spelling for the word.
@property (nonatomic, readonly, copy) NSString * _Nullable writtenAs;
/// Creates a word with the specified name and alternative spelling.
/// \param word the specific word described as a string.
///
/// \param writtenAs Defines an alternative spelling for the word.
///
- (nonnull instancetype)initWithWord:(NSString * _Nonnull)word writtenAs:(NSString * _Nullable)writtenAs OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 5.6.1 (swiftlang-5.6.0.323.66 clang-1316.0.20.12)
#ifndef MISPEECHKIT_SWIFT_H
#define MISPEECHKIT_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="miSpeechKit",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class NSString;

/// An Object which is used to specify configuration  used for the recognition session.
SWIFT_CLASS("_TtC11miSpeechKit18ApplicationContext")
@interface ApplicationContext : NSObject
/// The SpeaKING system which will be used for the recognition session.
/// If there only is one system this can be left nil.
@property (nonatomic, copy) NSString * _Nullable system;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// An object which will be used to authenticate against the web API.
SWIFT_CLASS("_TtC11miSpeechKit21AuthenticationContext")
@interface AuthenticationContext : NSObject
/// The System to connect with.
/// If there is only one system, this can be nil.
@property (nonatomic, copy) NSString * _Nullable system;
/// The User that is used for the connection.
@property (nonatomic, copy) NSString * _Nullable user;
/// The password of the specified user.
@property (nonatomic, copy) NSString * _Nullable password;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSUUID;
enum SessionState : NSInteger;
@class RecognitionContext;
@class Word;

/// The protocol for the RecognitionCore-Class
SWIFT_PROTOCOL("_TtP11miSpeechKit12IRecognition_")
@protocol IRecognition
/// Describes the current session. If this Id is nil there is no session initialized.
@property (nonatomic, readonly, copy) NSUUID * _Nullable id;
/// Discribes the current state of the recognition session.
@property (nonatomic, readonly) enum SessionState state;
/// Create a new recognition session and reserve a free recognition unit on server.
/// The session is defined between server and this client. The session identifier, that represent the session, is used for each method call internal. Do not change or use this property.
/// If the call is finished the result is notify by callback.
/// The call can only done if no session is started yet.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.initialize(RecognitionContext(user: "Diktierer")) { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param context Defines the user, vocabulary etc. for the newly created session.
///
/// \param completion The method that is called after the session is created or an error occured.
///
- (void)initialize:(RecognitionContext * _Nonnull)context completion:(void (^ _Nonnull)(BOOL))completion;
/// Temporarly add a new word to the vocabulary, which will be removed when the session is closed.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.addWord("Patientenname") { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param word The word as a String, which will be added to the vocabulary
///
/// \param completion The method that is called after the word is added or an error occured.
///
- (void)addWord:(NSString * _Nonnull)word completion:(void (^ _Nonnull)(BOOL))completion;
/// Temporarly add multiple new word to the vocabulary, which will be removed when the session is closed.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.addWords(["Patientenname"]) { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param words A list of words as Strings, which will be added to the vocabulary
///
/// \param completion The method that is called after the words are added or an error occured.
///
- (void)addWords:(NSArray<NSString *> * _Nonnull)words completion:(void (^ _Nonnull)(BOOL))completion;
/// Temporarly add a new word, where the writing differes from the word itself,  to the vocabulary, which will be removed when the session is closed.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.addWordWithDifferentWriting(Word(word: "Patientenname", writingAs: "Patientname")) { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param word The word as an object with a different writing , which will be added to the vocabulary
///
/// \param completion The method that is called after the word is added or an error occured.
///
- (void)addWordWithDifferentWriting:(Word * _Nonnull)word completion:(void (^ _Nonnull)(BOOL))completion;
/// Temporarly add a list of new words, where the writing differes from the word itself,  to the vocabulary, which will be removed when the session is closed.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.addWordsWithDifferentWriting([Word(word: "Patientenname", writingAs: "Patientname")]) { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param words A list of  words as  objects with a different writing , which will be added to the vocabulary
///
/// \param completion The method that is called after the word is added or an error occured.
///
- (void)addWordsWithDifferentWriting:(NSArray<Word *> * _Nonnull)words completion:(void (^ _Nonnull)(BOOL))completion;
/// Start the recognition engine at server and the audio engine. All recorded audio where transfered.
/// Set the text context to help the recognition engine. If line start or dictation start, set the previous context to nil.
/// In case of a connection loss, there will be attempts to reconnect to the server for 10 seconds, afterwards the recording will be stopped and the buffered audio will be dropped.
/// If the reconnect succeded the buffered audio will be transfered ofer to the recognition server and the recoding will continue seamelessly.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.start(previousText: "", followingText: "") { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param previousText The text that is recognized befor the new data should insert.
///
/// \param followingText The text that is after the new text is insert. 
///
/// \param completion The method is called if the recognition engine and the audio engine are started successful or an error occured.
///
- (void)startWithPreviousText:(NSString * _Nonnull)previousText followingText:(NSString * _Nonnull)followingText completion:(void (^ _Nonnull)(BOOL))completion;
/// Stop the recognition at server and force to send the recognized data to client.
/// Stop the audio engine.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.stop { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param completion The method is called if the recognition and and audio engine are stopped successfully of an error occured.
///
- (void)stopWithCompletion:(void (^ _Nonnull)(BOOL))completion;
/// Submitting text to the smart learning web service to train the used vocabulary permanently.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.submitText("Dies ist ein Beispieltext") { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param text The text to submit to smart learning
///
/// \param completion The method that is called when the text is submitted or an error ocurred.
///
- (void)submitText:(NSString * _Nonnull)text completion:(void (^ _Nonnull)(BOOL))completion;
/// Close the current recognition session and release all resources at server.
/// Call this method every time if the recognition session is initialized. If no session is started, nothing happens.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.cleanup { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param completion The method that is called when the cleanup is finished or an error occured.
///
- (void)cleanupWithCompletion:(void (^ _Nonnull)(BOOL))completion;
/// Release all resources at clientside
/// Call this method every time if the recognition session is initialized. If no session is started, nothing happens.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.dispose { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param completion The method that is called when the cleanup is finished or an error occured.
///
- (void)disposeWithCompletion:(void (^ _Nonnull)(BOOL))completion;
@end


/// The Protocol for all delegate methodes needed for the IRecognition-Object
SWIFT_PROTOCOL("_TtP11miSpeechKit20IRecognitionDelegate_")
@protocol IRecognitionDelegate
@optional
/// Is called if the session state is changed.
/// \param state The current session state.
///
- (void)onStateChangedWithState:(enum SessionState)state;
/// Is called if an error occured.
/// \param error The error that is occured.
///
- (void)onErrorWithError:(NSString * _Nonnull)error;
/// Is called if the recognition received result.
/// \param result The recognition result as plain text.
///
- (void)onResultWithResult:(NSString * _Nonnull)result;
/// Is called if a preview result is received.
/// \param previewResult A string with the preview result.
///
- (void)onPreviewResultWithPreviewResult:(NSString * _Nonnull)previewResult;
/// Is called when the voice level changed while recording
/// \param level The current voice level
///
- (void)onVoiceLevelChangedWithLevel:(float)level;
@end


/// An Object which describes an Error in the   SpeaKING context.
SWIFT_CLASS("_TtC11miSpeechKit7MIError")
@interface MIError : NSObject
/// The session id, if the error occured on the server side, describes the session from which the error comes from.
@property (nonatomic, readonly, copy) NSUUID * _Nullable sessionId;
/// The error code of the occured error.
@property (nonatomic, readonly) NSInteger errorCode;
/// A message which describes the error further.
@property (nonatomic, readonly, copy) NSString * _Nonnull errorMessage;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// An object that is used to initialize the recognition session with a specific configuration.
SWIFT_CLASS("_TtC11miSpeechKit18RecognitionContext")
@interface RecognitionContext : NSObject
/// Describes the user who is currently using speech recognition.
@property (nonatomic, copy) NSString * _Nonnull user;
/// Describtes the vocabulary which should be used for the recognition.
/// Can be nil if there only is one vocabulary for the specified user.
@property (nonatomic, copy) NSString * _Nullable vocabulary;
/// Decides whether a speech recognition preview should be delivered or not.
@property (nonatomic) BOOL previewResults;
/// Decides wheather to use the debug mode while using the speech recognition or not.
@property (nonatomic) BOOL debug;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The Core Object to use speech recognition with the SDK.
SWIFT_CLASS("_TtC11miSpeechKit15RecognitionCore")
@interface RecognitionCore : NSObject <IRecognition>
/// The current Session Id.
/// If this Id is nil there is no session initialized.
@property (nonatomic, readonly, copy) NSUUID * _Nullable id;
/// The current session state
/// Discribes the current state of the recognition session.
@property (nonatomic, readonly) enum SessionState state;
/// Create a new recognition session and reserve a free recognition unit on server.
/// The session is defined between server and this client. The session identifier, that represent the session, is used for each method call internal. Do not change or use this property.
/// If the call is finished the result is notify by callback.
/// The call can only done if no session is started yet.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.initialize(RecognitionContext(user: "Diktierer")) { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param context Defines the user, vocabulary etc. for the newly created session.
///
/// \param completion The method that is called after the session is created or an error occured.
///
- (void)initialize:(RecognitionContext * _Nonnull)context completion:(void (^ _Nonnull)(BOOL))completion;
/// Temporarly add a new word to the vocabulary, which will be removed when the session is closed.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.addWord("Patientenname") { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param word The word as a String, which will be added to the vocabulary
///
/// \param completion The method that is called after the word is added or an error occured.
///
- (void)addWord:(NSString * _Nonnull)word completion:(void (^ _Nonnull)(BOOL))completion;
/// Temporarly add multiple new word to the vocabulary, which will be removed when the session is closed.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.addWords(["Patientenname"]) { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param words A list of words as Strings, which will be added to the vocabulary
///
/// \param completion The method that is called after the words are added or an error occured.
///
- (void)addWords:(NSArray<NSString *> * _Nonnull)words completion:(void (^ _Nonnull)(BOOL))completion;
/// Temporarly add a new word, where the writing differes from the word itself,  to the vocabulary, which will be removed when the session is closed.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.addWordWithDifferentWriting(Word(word: "Patientenname", writingAs: "Patientname")) { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param word The word as an object with a different writing , which will be added to the vocabulary
///
/// \param completion The method that is called after the word is added or an error occured.
///
- (void)addWordWithDifferentWriting:(Word * _Nonnull)word completion:(void (^ _Nonnull)(BOOL))completion;
/// Temporarly add a list of new words, where the writing differes from the word itself,  to the vocabulary, which will be removed when the session is closed.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.addWordsWithDifferentWriting([Word(word: "Patientenname", writingAs: "Patientname")]) { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param words A list of  words as  objects with a different writing , which will be added to the vocabulary
///
/// \param completion The method that is called after the word is added or an error occured.
///
- (void)addWordsWithDifferentWriting:(NSArray<Word *> * _Nonnull)words completion:(void (^ _Nonnull)(BOOL))completion;
/// Start the recognition engine at server and the audio engine. All recorded audio where transfered.
/// Set the text context to help the recognition engine. If line start or dictation start, set the previous context to nil.
/// In case of a connection loss, there will be attempts to reconnect to the server for 10 seconds, afterwards the recording will be stopped and the buffered audio will be dropped.
/// If the reconnect succeded the buffered audio will be transfered ofer to the recognition server and the recoding will continue seamelessly.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.start(previousText: "", followingText: "") { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param previousText The text that is recognized befor the new data should insert.
///
/// \param followingText The text that is after the new text is insert. 
///
/// \param completion The method is called if the recognition engine and the audio engine are started successful or an error occured.
///
- (void)startWithPreviousText:(NSString * _Nonnull)previousText followingText:(NSString * _Nonnull)followingText completion:(void (^ _Nonnull)(BOOL))completion;
/// Stop the recognition at server and force to send the recognized data to client.
/// Stop the audio engine.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.stop { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param completion The method is called if the recognition and and audio engine are stopped successfully of an error occured.
///
- (void)stopWithCompletion:(void (^ _Nonnull)(BOOL))completion;
/// Submitting text to the smart learning web service to train the used vocabulary permanently.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.submitText("Dies ist ein Beispieltext") { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param text The text to submit to smart learning
///
/// \param completion The method that is called when the text is submitted or an error ocurred.
///
- (void)submitText:(NSString * _Nonnull)text completion:(void (^ _Nonnull)(BOOL))completion;
/// Close the current recognition session and release all resources at server.
/// Call this method every time if the recognition session is initialized. If no session is started, nothing happens.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.cleanup { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param completion The method that is called when the cleanup is finished or an error occured.
///
- (void)cleanupWithCompletion:(void (^ _Nonnull)(BOOL))completion;
/// Release all resources at clientside
/// Call this method every time if the recognition session is initialized. If no session is started, nothing happens.
/// <h1>Usage</h1>
/// \code
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) { recognition, error
///     recognition.dispose { result
///         // TODO: Your Code here
///     }
/// }
///
/// \endcode\param completion The method that is called when the cleanup is finished or an error occured.
///
- (void)disposeWithCompletion:(void (^ _Nonnull)(BOOL))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// The session state represent a recognition session. This values are set at recognition server.
typedef SWIFT_ENUM(NSInteger, SessionState, open) {
/// The session state is unknown or no session is started at the moment.
  SessionStateUnknown = 0,
/// The session  is created but the server is not ready to start the recognition.
  SessionStateCreated = 1,
/// The session will be ready soon. The Recording can be started and will be recognized as soon as the session is ready.
  SessionStateLoading = 2,
/// Started session is ready for  recognition.
  SessionStateReady = 3,
/// The session is updating the vocabulary and the new one will be available soon.
  SessionStateUpdating = 4,
/// The recognition is in process and the server waits for the audio data.
  SessionStateInProcess = 5,
/// The recognition is unloading. The Recording should be finished and the session is near to be closed.
  SessionStateUnloading = 6,
/// The session is suspended after no audio data where transfered a while. The session is restarted if new audio data where available but it can take a while.
  SessionStateSuspended = 7,
/// The session is stopped and all resources are released at the server. The session can not recreated to continue recognition.
/// Create a new session if recognition should continue.
  SessionStateClosed = 8,
/// An error occuered during session creation. The session is closed and the error state is set. See callback method for more information.
  SessionStateError = 9,
};


/// This class is used to generate and configure a recognition and to pre select an available recognition server.
/// <h1>Usage</h1>
/// \code
///
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) {
///     recognition, error
///     // TODO: Your Code here
/// }
///
///
/// \endcode
SWIFT_CLASS("_TtC11miSpeechKit8SpeaKING")
@interface SpeaKING : NSObject
/// Initialized a configured instance of
/// <h1>Usage</h1>
/// \code
///
/// SpeaKING.getRecognition("http://speaking-server/", delegate = self) {
///      recognition, error
///      // TODO: Your Code here
/// }
///
///
/// \endcode\param server The url of the speaking server instance
///
/// \param context The authentication connext for the SpeaKING Server
///
/// \param delegate The delegate to receive updates about the ongoing process of recognition.
///
/// \param completion The completion handle will be triggered, when the recognition api instance is ready for usage.
///
+ (void)getRecognition:(NSString * _Nullable)server context:(AuthenticationContext * _Nullable)context delegate:(id <IRecognitionDelegate> _Nonnull)delegate completion:(void (^ _Nonnull)(id <IRecognition> _Nullable, MIError * _Nullable))completion;
/// Authenticate the given user agaist the coresponding speaking server.
/// #Usage
/// \code
/// SpeaKING.login("http://speaking-server") { error in
///      // TODO: Your code here
/// }
///
///
/// \endcode<ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     server: The url of the speaking server instance
///   </li>
///   <li>
///     context: The authentication context for the speaking instance
///   </li>
///   <li>
///     completion: The complition handle will be triggered when the authentication process is finished.
///   </li>
/// </ul>
+ (void)login:(NSString * _Nullable)server context:(AuthenticationContext * _Nullable)context completion:(void (^ _Nonnull)(MIError * _Nullable))completion;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



/// An Object that specifies a word to add temporarely to a vocabulary
SWIFT_CLASS("_TtC11miSpeechKit4Word")
@interface Word : NSObject
/// The specific word described as a string.
@property (nonatomic, readonly, copy) NSString * _Nonnull word;
/// Defines an alternative spelling for the word.
@property (nonatomic, readonly, copy) NSString * _Nullable writtenAs;
/// Creates a word with the specified name and alternative spelling.
/// \param word the specific word described as a string.
///
/// \param writtenAs Defines an alternative spelling for the word.
///
- (nonnull instancetype)initWithWord:(NSString * _Nonnull)word writtenAs:(NSString * _Nullable)writtenAs OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#endif
